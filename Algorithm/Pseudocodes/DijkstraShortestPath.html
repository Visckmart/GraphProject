<pre label="init">
<span>Inicializando minimum heap com os</span>
<span>nós classificados por distância</span>
heap = MinHeap()

<span>Inicializando todos os nós</span>
for(nó de grafo) {
    nó.distancia = ∞
    nó.anterior = null
    nó.visitado = false

    heap.insert(nó)
}
<span>Inicializando nó inicial</span>
nóInicial.distancia = 0


nóCorrente = null
</pre>
<pre label="startLoop">
while (nóCorrente !== nóFinal) {
    <span>Recupera o nó com menor distância do heap</span>
    nóCorrente = heap.remove()

    <span>Finaliza o loop caso o nó corrente não exista ou</span>
    <span>tenha distância ∞</span>
    if(nóCorrente == null || nóCorrente.distancia = ∞) {
        break
    }
    </pre>
    <pre label="selectEdge">
    for(aresta saindo de nóCorrente) {
        nóDestino = destino(aresta)

        <span>Ignora essa aresta caso leve para o nó anterior</span>
        if(nóDestino === nóCorrente.anterior) {
        continue
        }

        <span>Calculando nova distância hipotética entre</span>
        <span>nóInicial e o nóDestino</span>
        novaDistância = nóCorrente.distancia + aresta.peso
        </pre>
        <pre label="newDistance">
        if(novaDistância < nóDestino.distancia) {
            <span>Atualizando distância do nó destino já que</span>
            <span>a distância encontrada é menor</span>
            nóDestino.distancia = novaDistância
            nóDestino.anterior = nóCorrente

            heap.atualizaPeso(nóDestino, nóDestino.distancia)
        }
        </pre>
        <pre label="noNewDistance">
        else {
            <span>Ignorando aresta já que a distância encontrada</span>
            <span>é maior que a distância atual</span>
            ignora aresta
        }
    }
</pre>
<pre label="end">
}
<span>Se chegamos ao nó final então encontramos um caminho</span>
if(nóCorrente === nóFinal) {
    return caminho encontrado de nóInicial à nóFinal
}
<span>Caso contrário não havia caminho</span>
else {
    return null
}
</pre>